{"ts":1367292048092,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"---\nlayout: post\ntitle: \"Java Proxy Chaining - Aspect on the Cheap\"\ndate: 2013-04-28 21:01\ncomments: true\ncategories: [programming java] \n---\n\nHow many of you have written a caching solution for one of your expensive method calls? Or how about retry logic for your service calls?\nLiving in such a connected world no single application is its own island. For every applications I have worked for, there always external dependencies, either other service APIs or\ndatabases that we need to rely upon. And we can't make the assumption that they are reliable 100% either.\n\nSome service calls are expensive and the underlying data don't change so often. We tend to cache the results. A naive approach would be to find such methods and refactor them \nso that cache can be used before the call to the services are made. The better way is to use AOP where you intercept those calls with 'aspects'. The in those aspects you can make the decision to whether get the results from the cache or to make the expensive service calls.\nAnother common scenario is retry when you encounter exceptions in your service calls: transient network issues (latency, timed out, spillover in load balancer...) or database hiccups.\nNormally, you should at least retry the calls for several times before giving up. Like noted previously, a naive approach would be to go every methods and apply the retry logic. Or you could use AOP.\n\nIn this post, I'm going to talk about how to use aspect oriented way to easy the refactoring effort. I will not talk about the full blown bytecode level AOP solution which uses AspectJ\nwith bytecode weaving. Instead, I will talk about a lighter weight of aspect programming using the Java's dynamic proxy and its reflection mechanism. I think it's pretty similar to the way Spring\nAOP works. The only difference is that my code will assume every method calls implement interfaces. Thus, it will not have to use cglib to generate the proxies. Also, I think programming to interface\nis a much cleaner and prefer way for your service calls Data access objects.\n\n<!-- more -->\n\n``` java Invocation\nprotected static final <T> T findRealTarget(T t)\n    {\n        if (!Proxy.isProxyClass(t.getClass()))\n            return t;\n        InvocationHandler ih = Proxy.getInvocationHandler(t);\n        if (AbstractInvocationHandler.class.isInstance(ih))\n        {\n            return (T) ((AbstractInvocationHandler) ih).getRealTarget();\n        } else\n        {\n            try\n            {\n                Field f = findField(ih.getClass(), \"target\");\n                if (Object.class.isAssignableFrom(f.getType())\n                        && !f.getType().isArray())\n                {\n\n                    f.setAccessible(true); // suppress access checks\n                    Object innerTarget = f.get(ih);\n                    return (T) findRealTarget(innerTarget);\n                }\n                return null;\n            } catch (NoSuchFieldException e)\n            {\n                return null;\n            } catch (SecurityException e)\n            {\n                return null;\n            } catch (IllegalAccessException e)\n            {\n                return null;\n            } // IllegalArgumentException cannot be raised\n        }\n    }\n\n```\n"]],"start1":0,"start2":0,"length1":0,"length2":3247}]],"length":3247}
{"contributors":[],"silentsave":false,"ts":1367292075457,"patch":[[{"diffs":[[0,"et(T t)\n"],[-1,"    {\n    "],[1,"{\n"],[0,"    if ("]],"start1":2138,"start2":2138,"length1":26,"length2":18},{"diffs":[[0,")))\n        "],[-1,"    "],[0,"return t;\n  "]],"start1":2187,"start2":2187,"length1":28,"length2":24},{"diffs":[[0,"turn t;\n"],[-1,"    "],[0,"    Invo"]],"start1":2201,"start2":2201,"length1":20,"length2":16},{"diffs":[[0,"Handler(t);\n"],[-1,"    "],[0,"    if (Abst"]],"start1":2255,"start2":2255,"length1":28,"length2":24},{"diffs":[[0,"ce(ih))\n"],[-1,"    "],[0,"    {\n  "]],"start1":2315,"start2":2315,"length1":20,"length2":16},{"diffs":[[0,")\n    {\n        "],[-1,"    "],[0,"return (T) ((Abs"]],"start1":2321,"start2":2321,"length1":36,"length2":32},{"diffs":[[0,"rget();\n"],[-1,"    "],[0,"    } el"]],"start1":2390,"start2":2390,"length1":20,"length2":16},{"diffs":[[0," } else\n    "],[-1,"    {\n    "],[1,"{\n"],[0,"        try\n"]],"start1":2401,"start2":2401,"length1":34,"length2":26},{"diffs":[[0,"try\n        "],[-1,"    {\n    "],[1,"{\n"],[0,"            "]],"start1":2423,"start2":2423,"length1":34,"length2":26},{"diffs":[[0,"        "],[-1,"    "],[0,"if (Obje"]],"start1":2499,"start2":2499,"length1":20,"length2":16},{"diffs":[[0,"        "],[-1,"    "],[0,"&& !f.ge"]],"start1":2566,"start2":2566,"length1":20,"length2":16},{"diffs":[[0,"    "],[-1,"    {\n\n    "],[1,"{\n\n"],[0,"    "]],"start1":2609,"start2":2609,"length1":19,"length2":11},{"diffs":[[0,"        "],[-1,"    "],[0,"Object i"]],"start1":2689,"start2":2689,"length1":20,"length2":16},{"diffs":[[0,"et(ih);\n"],[-1,"    "],[0,"        "]],"start1":2721,"start2":2721,"length1":20,"length2":16},{"diffs":[[0,"        "],[-1,"    }\n    "],[1,"}\n"],[0,"        "]],"start1":2789,"start2":2789,"length1":26,"length2":18},{"diffs":[[0,"n null;\n        "],[-1,"    "],[0,"} catch (NoSuchF"]],"start1":2816,"start2":2816,"length1":36,"length2":32},{"diffs":[[0,"eldException e)\n"],[-1,"    "],[0,"        {\n      "]],"start1":2849,"start2":2849,"length1":36,"length2":32},{"diffs":[[0,"  {\n            "],[-1,"    "],[0,"return null;\n   "]],"start1":2871,"start2":2871,"length1":36,"length2":32},{"diffs":[[0,"   return null;\n"],[-1,"    "],[0,"        } catch "]],"start1":2884,"start2":2884,"length1":36,"length2":32},{"diffs":[[0," e)\n        "],[-1,"    {\n    "],[1,"{\n"],[0,"            "]],"start1":2934,"start2":2934,"length1":34,"length2":26},{"diffs":[[0,"   return null;\n"],[-1,"    "],[0,"        } catch "]],"start1":2957,"start2":2957,"length1":36,"length2":32},{"diffs":[[0,"xception e)\n"],[-1,"    "],[0,"        {\n  "]],"start1":3004,"start2":3004,"length1":28,"length2":24},{"diffs":[[0,"  {\n            "],[-1,"    "],[0,"return null;\n   "]],"start1":3022,"start2":3022,"length1":36,"length2":32},{"diffs":[[0,"eturn null;\n"],[-1,"    "],[0,"        } //"]],"start1":3039,"start2":3039,"length1":28,"length2":24},{"diffs":[[0,"sed\n    "],[-1,"    }\n    "],[1,"}\n"],[0,"}\n\n```\n"]],"start1":3102,"start2":3102,"length1":25,"length2":17}]],"length":3119,"saved":false}
{"ts":1367292445645,"patch":[[{"diffs":[[0," objects"],[1," (DAO)"],[0,".\n\n<!-- "]],"start1":2051,"start2":2051,"length1":16,"length2":22},{"diffs":[[0,"re -->\n\n"],[1,"Let's define an example interface for the DAO and its implementation.\n\n``` java Interface\ninterface Say\n{\n    public void say();\n}\n\npublic void say()\n{\n    Random rand = new Random();\n\tint r = rand.nextInt(9);\n\tif (r > 7)\n\t{\n\t\tthrow new RuntimeException(\"CRAP please retry!!\");\n\t}\n\t\n    System.out.println(\"Say hello\");\n}\n```\n\nI intentionally throw a RuntimeException 30% of the times this method run to simulation transient error that could be retried.\n\n"],[0,"``` java"]],"start1":2075,"start2":2075,"length1":16,"length2":471}]],"length":3580,"saved":false}
{"ts":1367292802015,"patch":[[{"diffs":[[0,"retried."],[1,"\nNow is the fun part: we will add additional functionalities over this method without modifying its code. As the begining I want to time the method performance\nand retry if it fails (up to 3 times before I give up).\n\nThe easiest way to do this is to use annotation to denote your new aspects.\n\n``` java Timing Aspect Annotation\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.RUNTIME)\n@interface Timeit\n{  \n}\n```\n\nAnd the Retry aspect:\n\n``` java Retry Aspect\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.RUNTIME)\n@interface Retry\n{\n    int times() default 3;\n}\n```"],[0,"\n\n``` ja"]],"start1":2528,"start2":2528,"length1":16,"length2":597}]],"length":4161,"saved":false}
{"ts":1367292816978,"patch":[[{"diffs":[[0,"y aspect"],[1," with maximum of 3 retries before giving up"],[0,":\n\n``` j"]],"start1":2969,"start2":2969,"length1":16,"length2":59}]],"length":4204,"saved":false}
{"ts":1367293222707,"patch":[[{"diffs":[[0,"``\n\n"],[-1,"``` java Invocation\nprotected static final <T> T findRealTarget(T t)\n{\n    if (!Proxy.isProxyClass(t.getClass()))\n        return t;\n    InvocationHandler ih = Proxy.getInvocationHandler(t);\n    if (AbstractInvocationHandler.class.isInstance(ih))\n    {\n        return (T) ((AbstractInvocationHandler) ih).getRealTarget();\n    } else\n    {\n        try\n        {\n            Field f = findField(ih.getClass(), \"t"],[1,"In order to facilitate the annotations in the java dynamic proxy, we need to create an InvocationHandler for each of those annotations.\nFor this I first borrow the utility class from \"Java Reflection in Action\". You can get full source at the end of this post.\n\n``` java AbstractInvocationHandler\npublic abstract class AbstractInvocationHandler<T> implements InvocationHandler\n{\n\n    protected T nextT"],[0,"arget"],[-1,"\")"],[0,";\n    "],[-1,"        if (Object.class.isAssignableFrom(f.getType())\n                    && !f.getType().isArray())\n        "],[1,"protected T realTarget = null;\n\n    public AbstractInvocationHandler(T target)\n"],[0,"    {\n"],[-1,"\n "],[0,"        "],[-1,"       f.setAccessible(true); // suppress access checks\n                Object inner"],[1,"nextTarget = target;\n        if (next"],[0,"Target "],[1,"!"],[0,"= "],[-1,"f.get(ih);"],[1,"null)"],[0,"\n    "],[1,"    {\n"],[0,"    "]],"start1":3158,"start2":3158,"length1":664,"length2":576},{"diffs":[[0,"  re"],[-1,"turn (T)"],[1,"alTarget ="],[0," fin"]],"start1":3740,"start2":3740,"length1":16,"length2":18},{"diffs":[[0,"get("],[-1,"inner"],[1,"next"],[0,"Targ"]],"start1":3766,"start2":3766,"length1":13,"length2":12},{"diffs":[[0,"    "],[-1,"}\n            return null;\n        } catch (NoSuchFieldException e"],[1,"if (realTarget == null"],[0,")\n  "]],"start1":3791,"start2":3791,"length1":74,"length2":30},{"diffs":[[0,"    "],[-1,"{\n"],[0,"        "],[-1,"    return null;\n        } catch (SecurityException e)\n        {\n            return null;\n        } catch (IllegalAccessException e)\n        {\n            return null;\n        } // IllegalArgumentException cannot be raised"],[1,"throw new RuntimeException(\"findRealTarget failure\");\n        }\n    }"],[0,"\n    "],[-1,"}"],[1,"..."],[0,"\n}\n"],[-1,"\n"],[0,"```\n"],[1,"\n\n"]],"start1":3823,"start2":3823,"length1":250,"length2":98}]],"length":3921,"saved":false}
{"ts":1367293537128,"patch":[[{"diffs":[[0,"is post."],[1,"\nI then create a base Interceptor on top of this invocation handler to make the dynamic proxy generation handling annoations easier."],[0,"\n\n``` ja"]],"start1":3414,"start2":3414,"length1":16,"length2":148},{"diffs":[[0,"nHandler"],[1," and The base Invoker"],[0,"\npublic "]],"start1":3582,"start2":3582,"length1":16,"length2":37},{"diffs":[[0,"\n    ..."],[-1,""],[0,""],[1,"\n}\n\ninterface RealInvoker\n{\n    public Object invoke() throws Throwable;\n}\n\ninterface Invoker<A extends Annotation>\n{\n\tpublic Object execute(final Method method, final Object[] args, A ann, RealInvoker realInvoker) throws Throwable;\n}\n\nclass Interceptor<T, A extends Annotation> extends AbstractInvocationHandler<T>\n{\n    private Class<A> annotationClass;\n\tprivate Invoker<A> invoker;\n\t\n\tprivate Interceptor(T target, Class<A> annotationClass, Invoker<A> invoker)\n    {\n        super(target);\n        this.annotationClass = annotationClass;\n        this.invoker = invoker;\n    }\n\t\n\tpublic static <T, A extends Annotation> T createProxy(T obj, Class<A> annotationClass, Invoker<A> invoker)\n    {\n        return (T) Proxy.newProxyInstance(obj.getClass().getClassLoader(), obj\n                .getClass().getInterfaces(), new Interceptor(obj, annotationClass, invoker));\n    }\n\t\n\t@Override\n\tpublic Object invoke(Object proxy, final Method method, final Object[] args)\n\t\t\tthrows Throwable {\n\t\tObject result = null;\n\t\tA annotation = (A) this.realTarget.getClass().getMethod(method.getName()).getAnnotation(annotationClass);\n        if (annotation != null)\n        {\n        \treturn invoker.execute(method, args, annotation, new RealInvoker() {\n\t\t\t\t@Override\n\t\t\t\tpublic Object invoke() throws Throwable {\n\t\t\t\t\treturn method.invoke(Interceptor.this.nextTarget, args);\n\t\t\t\t}\n\t\t\t});\n        }\n        else\n        {\n            result = method.invoke(this.nextTarget, args);\n        }\n\n        return result;\n\t}\n\t"],[0,"\n}\n```\n\n"]],"start1":4057,"start2":4057,"length1":16,"length2":1520}]],"length":5578,"saved":false}
{"ts":1367293556983,"patch":[[{"diffs":[[0,"    "],[-1,"private Class<A> annotationClass;\n\tprivate Invoker<A> invoker;\n\t\n\tprivate Interceptor(T target, Class<A> annotationClass, Invoker<A> invoker)\n    {\n        super(target);\n        this.annotationClass = annotationClass;\n        this.invoker = invoker;\n    }\n\t\n\tpublic static <T, A extends Annotation> T createProxy(T obj, Class<A> annotationClass, Invoker<A> invoker)\n    {\n        return (T) Proxy.newProxyInstance(obj.getClass().getClassLoader(), obj\n                .getClass().getInterfaces(), new Interceptor(obj, annotationClass, invoker));\n    }"],[1,"..."],[0,"\n\t\n\t"]],"start1":4383,"start2":4383,"length1":559,"length2":11}]],"length":5030,"saved":false}
{"ts":1367293566848,"patch":[[{"diffs":[[0,"ult;\n\t}\n"],[-1,"\t\n"],[0,"}\n```\n\n\n"]],"start1":5012,"start2":5012,"length1":18,"length2":16}]],"length":5028,"saved":false}
{"ts":1367293604999,"patch":[[{"diffs":[[0,"  ...\n\t\n"],[1,"    public static <T, A extends Annotation> T createProxy(T obj, Class<A> annotationClass, Invoker<A> invoker)\n    {\n        return (T) Proxy.newProxyInstance(obj.getClass().getClassLoader(), obj\n                .getClass().getInterfaces(), new Interceptor(obj, annotationClass, invoker));\n    }\n    \n"],[0,"\t@Overri"]],"start1":4385,"start2":4385,"length1":16,"length2":317},{"diffs":[[0,"\n}\n```\n\n"],[1,"The "],[0,"\n"]],"start1":5320,"start2":5320,"length1":9,"length2":13}]],"length":5333,"saved":false}
{"ts":1367293966907,"patch":[[{"diffs":[[0,"``\n\nThe "],[1,"nice thing in doing this is that in order to create an aspect based on an annotation you just need to implement the Invoker interface shown above.\nThen you can create the dynamic proxy of the targeted object by calling:\n\n``` java Creating the Dynamic Proxy\n// Some dao needed to be wrapped in Timeit aspect\nSomeDao dao = ...\ndao = Interceptor.createProxy(obj, Timeit.class, new TimerAspect());\n```\n\nInterceptor.createProxy takes 3 arguments: the targeted object to be proxied, the aspect annotation class and the object to handle the aspect.\nFor the Timer (or Timeit) aspect, it could be as simple as this:\n\n``` java Timeit Aspect\npublic class TimerAspect implements Invoker<Timeit>\n{\n    @Override\n\tpublic Object execute(Method method, Object[] args, Timeit ann,\n\t\t\tRealInvoker realInvoker) throws Throwable {\n\t\tlong start = System.nanoTime();\n\t\tObject result = realInvoker.invoke();\n\t\tSystem.out.println(String.format(\"-- %s tookkkk %s ms\", method.getName(), (System.nanoTime() - start) / 1000000.0));\n\t\treturn result;\n\t}    \n}\n```\n"],[0,"\n"]],"start1":5324,"start2":5324,"length1":9,"length2":1043}]],"length":6367,"saved":false}
{"ts":1367294104169,"patch":[[{"diffs":[[0,";\n\t}    \n}\n```\n\n"],[1,"Here is why this is an aspect: the execute method takes note of the current time. It then invokes the original method call. Finally it calculate\nhow long this method call takes. I believe in AspectJ this is called \"before and around pointcut\".\n"]],"start1":6351,"start2":6351,"length1":16,"length2":260}]],"length":6611,"saved":false}
{"ts":1367294257138,"patch":[[{"diffs":[[0,"teProxy("],[-1,"obj"],[1,"dao"],[0,", Timeit"]],"start1":5679,"start2":5679,"length1":19,"length2":19},{"diffs":[[0,"ntcut\".\n"],[1,"\nSimilarly, I would create the Retry aspect by implementing the Invoker interface and call\n\n``` java Creating Retry aspect\ndao = Interceptor.createProxy(dao, Retry.class, new RetryAspect());\n```\n\nAfter we have the aspects to handle those annotations, how do chain them in a correct order, an order which makes sense at all?\n\n"]],"start1":6603,"start2":6603,"length1":8,"length2":333}]],"length":6936,"saved":false}
{"ts":1367294608606,"patch":[[{"diffs":[[0,"at all?\n"],[1,"It all depends on your aspects' logic but in this case I would make the Timer aspect inside of the Retry aspect. Confused? Here is the order of execution:\n1. Enter the Timer aspect, take note of the current time\n2. Enter the Rety aspect, retry count set to 0\n3. Invoke the actual Dao method\n4. If it fails, retry aspect catch the exception and retries! It keeps track of the number of retries (up to 3 times by default)\n5. Either the call fails if retries exceed 3 times or it exits the Retry aspect and yield the command to Timer Aspect again\n6. Timer aspect calculate how long this Dao method takes\n7. Return the result to the caller\n\n"],[0,"\n"]],"start1":6927,"start2":6927,"length1":9,"length2":646}]],"length":7573,"saved":false}
{"ts":1367294721892,"patch":[[{"diffs":[[0,"caller\n\n"],[1,"One thing you need to pay close attention is the order of the execution of those chained aspects influenced by the way you create them.\nThe inner most aspect will need to be created last. The outer most aspect will need to be created first.\n"],[0,"\n"]],"start1":7564,"start2":7564,"length1":9,"length2":250}]],"length":7814,"saved":false}
{"ts":1367294797020,"patch":[[{"diffs":[[0," first.\n"],[1,"For this example, this is the order of aspect creation:\n\n``` java Order of Aspect creation\nSomeDao dao = ...\ndao = Interceptor.createProxy(dao, Retry.class, new RetryAspect());\ndao = Interceptor.createProxy(dao, Timeit.class, new TimerAspect());\n\n```"],[0,"\n"]],"start1":7805,"start2":7805,"length1":9,"length2":259}]],"length":8064,"saved":false}
{"ts":1367294861868,"patch":[[{"diffs":[[0,"ect());\n"],[-1,"\n"],[0,"```\n"],[1,"\nHere is the complete code in 2 simple classes. I hope you find this useful.\n\n``` java Source Code\n\n```"]],"start1":8051,"start2":8051,"length1":13,"length2":115}]],"length":8166,"saved":false}
{"ts":1367295024390,"patch":[[{"diffs":[[0,"ava "],[-1,"Source Code\n"],[1,"AbstractInvocationHandler.java\nimport java.lang.reflect.*;\n\npublic abstract class AbstractInvocationHandler<T> implements InvocationHandler\n{\n\n    protected T nextTarget;\n    protected T realTarget = null;\n\n    public AbstractInvocationHandler(T target)\n    {\n        nextTarget = target;\n        if (nextTarget != null)\n        {\n            realTarget = findRealTarget(nextTarget);\n            if (realTarget == null)\n                throw new RuntimeException(\"findRealTarget failure\");\n        }\n    }\n\n    protected final T getRealTarget()\n    {\n        return realTarget;\n    }\n\n    protected static final <T> T findRealTarget(T t)\n    {\n        if (!Proxy.isProxyClass(t.getClass()))\n            return t;\n        InvocationHandler ih = Proxy.getInvocationHandler(t);\n        if (AbstractInvocationHandler.class.isInstance(ih))\n        {\n            return (T) ((AbstractInvocationHandler) ih).getRealTarget();\n        } else\n        {\n            try\n            {\n                Field f = findField(ih.getClass(), \"target\");\n                if (Object.class.isAssignableFrom(f.getType())\n                        && !f.getType().isArray())\n                {\n\n                    f.setAccessible(true); // suppress access checks\n                    Object innerTarget = f.get(ih);\n                    return (T) findRealTarget(innerTarget);\n                }\n                return null;\n            } catch (NoSuchFieldException e)\n            {\n                return null;\n            } catch (SecurityException e)\n            {\n                return null;\n            } catch (IllegalAccessException e)\n            {\n                return null;\n            } // IllegalArgumentException cannot be raised\n        }\n    }\n\n    public static Field findField(Class cls, String name)\n            throws NoSuchFieldException\n    {\n        if (cls != null)\n        {\n            try\n            {\n                return cls.getDeclaredField(name);\n            } catch (NoSuchFieldException e)\n            {\n                return findField(cls.getSuperclass(), name);\n            }\n        } else\n        {\n            throw new NoSuchFieldException();\n        }\n    }\n}\n```\n\n``` java Main.java\n\nimport java.lang.annotation.Annotation;\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Proxy;\nimport java.util.Random;\n\ninterface RealInvoker\n{\n    public Object invoke() throws Throwable;\n}\n\ninterface Invoker<A extends Annotation>\n{\n\tpublic Object execute(final Method method, final Object[] args, A ann, RealInvoker realInvoker) throws Throwable;\n}\n\nclass Interceptor<T, A extends Annotation> extends AbstractInvocationHandler<T>\n{\n\tprivate Class<A> annotationClass;\n\tprivate Invoker<A> invoker;\n\t\n\tprivate Interceptor(T target, Class<A> annotationClass, Invoker<A> invoker)\n    {\n        super(target);\n        this.annotationClass = annotationClass;\n        this.invoker = invoker;\n    }\n\t\n\tpublic static <T, A extends Annotation> T createProxy(T obj, Class<A> annotationClass, Invoker<A> invoker)\n    {\n        return (T) Proxy.newProxyInstance(obj.getClass().getClassLoader(), obj\n                .getClass().getInterfaces(), new Interceptor(obj, annotationClass, invoker));\n    }\n\t\n\t@Override\n\tpublic Object invoke(Object proxy, final Method method, final Object[] args)\n\t\t\tthrows Throwable {\n\t\tObject result = null;\n\t\tA annotation = (A) this.realTarget.getClass().getMethod(method.getName()).getAnnotation(annotationClass);\n        if (annotation != null)\n        {\n        \treturn invoker.execute(method, args, annotation, new RealInvoker() {\n\t\t\t\t@Override\n\t\t\t\tpublic Object invoke() throws Throwable {\n\t\t\t\t\treturn method.invoke(Interceptor.this.nextTarget, args);\n\t\t\t\t}\n\t\t\t});\n        }\n        else\n        {\n            result = method.invoke(this.nextTarget, args);\n        }\n\n        return result;\n\t}\n\t\n}\n\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.RUNTIME)\n@interface Timeit\n{  \n}\n\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.RUNTIME)\n@interface Cache\n{  \n}\n\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.RUNTIME)\n@interface Retry\n{\n\tint times() default 3;\n}\n\ninterface Say\n{\n    public void say();\n}\n\nclass ProxyFactory<T>\n{\n\tpublic static <T> T createProxy(T obj)\n\t{\n\t\tobj = Interceptor.createProxy(obj, Retry.class, new Invoker<Retry>()\n\t\t{\n\t\t\t@Override\n\t\t\tpublic Object execute(Method method, Object[] args, Retry ann,\n\t\t\t\t\tRealInvoker realInvoker) throws Throwable {\n\t\t\t\tObject result = null;\n\t\t\t\t\n\t\t\t\tint retries = 0;\n\t\t\t\twhile (retries < ann.times())\n\t\t\t\t{\n\t\t\t\t\ttry\n\t\t\t\t\t{\n\t\t\t\t\t\tresult = realInvoker.invoke();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Throwable crap)\n\t\t\t\t\t{\n\t\t\t\t\t\tretries++;\n\t\t\t\t\t\tSystem.out.println(String.format(\"Crap catched %s times\", retries));\n\t\t\t\t\t}\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (retries >= ann.times()) throw new RuntimeException(\"Can't handle it anymore\");\n\t\t\t\t\n\t\t\t\treturn result;\n\t\t\t}\n\t\t});\n\t\t\n\t\tobj = Interceptor.createProxy(obj, Timeit.class, new Invoker<Timeit>()\n\t\t{\n\t\t\t@Override\n\t\t\tpublic Object execute(Method method, Object[] args, Timeit ann,\n\t\t\t\t\tRealInvoker realInvoker) throws Throwable {\n\t\t\t\tSystem.out.println(\"-- Enter the timer\");\n\t\t\t\tlong start = System.nanoTime();\n\t\t\t\tObject result = realInvoker.invoke();\n\t\t\t\tSystem.out.println(String.format(\"-- %s tookkkk %s ms\", method.getName(), (System.nanoTime() - start) / 1000000.0));\n\t\t\t\treturn result;\n\t\t\t}\n\t\t});\n\t\t\n\t\treturn obj;\n\t}\n}\n\npublic class Main implements Say\n{\n    public static void main(String... args)\n    {\n        Say main = new Main();\n        main = ProxyFactory.createProxy(main);\n        \n        for (int i = 0; i < 10; i++)\n        {\n        \tmain.say();\n        \tSystem.out.println(\" ##### \\n\");\n        }\n    }\n\n    @Timeit\n    @Retry\n    public void say()\n    {\n    \tRandom rand = new Random();\n    \tint r = rand.nextInt(9);\n    \tif (r > 5)\n    \t{\n    \t\tthrow new RuntimeException(\"CRAP rety!!\");\n    \t}\n    \t\n        System.out.println(\"Say hello\");\n    }\n}"],[0,"\n```"]],"start1":8146,"start2":8146,"length1":20,"length2":6137}]],"length":14283,"saved":false}
{"ts":1367295092909,"patch":[[{"diffs":[[0,"hello\");\n    }\n}\n```"],[1,"\n\n``` java Cache Aspect\npublic CacheAspect implements Invoker\n{\n    ConcurrentMap<String, ConcurrentMap<Object, Object>> cache = new ConcurrentHashMap<>();\n    \t\t\n    @Override\n    public Object execute(Method method, Object[] args, Cache ann,\n    \t\tRealInvoker realInvoker) throws Throwable {\n    \t\n    \tSystem.out.println(\"@@ Entering cache proxy with \" + method.getName() + \" \" + args);\n        ConcurrentMap<Object, Object> theCache = cache.get(method.getName());\n        if (theCache == null)\n        {\n        \ttheCache = new ConcurrentHashMap<>();\n        \tcache.put(method.getName(), theCache);\n        }\n        \n        Object key = args;\n        if (args == null)\n        {\n        \tkey = \"\";\n        }\n        Object result = theCache.get(key);\n        if (result != null)\n        {\n        \tSystem.out.println(\"@@ Cache hit with \" + method.getName() + \" \" + args);\n        }\n        else\n        {\n        \tSystem.out.println(\"@@ Cache missed with \" + method.getName() + \" \" + args);\n        \tresult = realInvoker.invoke();\n        \ttheCache.put(key, result == null ? \"\" : result);\n        }\n        \n        System.out.println(\"@@ Exiting cache proxy\");\n        \n    \treturn result;\n}\n```"]],"start1":14263,"start2":14263,"length1":20,"length2":1222}]],"length":15485,"saved":false}
{"ts":1367295102149,"patch":[[{"diffs":[[0,"hrowable"],[1,"\n   "],[0," {\n    \t"]],"start1":14566,"start2":14566,"length1":16,"length2":20}]],"length":15489,"saved":false}
{"ts":1367295116042,"patch":[[{"diffs":[[0,"e\n    {\n"],[-1,"    \t\n"],[0,"    \tSys"]],"start1":14573,"start2":14573,"length1":22,"length2":16},{"diffs":[[0,"result;\n"],[-1,"}"],[1,"    }\n}    "],[0,"\n```"]],"start1":15470,"start2":15470,"length1":13,"length2":23}]],"length":15493,"saved":false}
{"ts":1367295329554,"patch":[[{"diffs":[[0," aspect "],[-1,"in"],[1,"out"],[0,"side of "]],"start1":7012,"start2":7012,"length1":18,"length2":19}]],"length":15494,"saved":false}
{"ts":1367295423400,"patch":[[{"diffs":[[0,"tion:\n1."],[1," "],[0," Enter t"]],"start1":7085,"start2":7085,"length1":16,"length2":17},{"diffs":[[0," time\n2."],[1," "],[0," Enter t"]],"start1":7143,"start2":7143,"length1":16,"length2":17},{"diffs":[[0," to 0\n3."],[1," "],[0," Invoke "]],"start1":7191,"start2":7191,"length1":16,"length2":17},{"diffs":[[0,"ethod\n4."],[1," "],[0," If it f"]],"start1":7224,"start2":7224,"length1":16,"length2":17},{"diffs":[[0,"ault)\n5."],[1," "],[0," Either "]],"start1":7354,"start2":7354,"length1":16,"length2":17},{"diffs":[[0,"again\n6."],[1," "],[0," Timer a"]],"start1":7479,"start2":7479,"length1":16,"length2":17},{"diffs":[[0,"takes\n7."],[1," "],[0," Return "]],"start1":7537,"start2":7537,"length1":16,"length2":17}]],"length":15501,"saved":false}
{"ts":1367295598274,"patch":[[{"diffs":[[0,"cution:\n"],[1,"\n    "],[0,"1.  Ente"]],"start1":7083,"start2":7083,"length1":16,"length2":21},{"diffs":[[0,"nt time\n"],[1,"    "],[0,"2.  Ente"]],"start1":7146,"start2":7146,"length1":16,"length2":20},{"diffs":[[0,"et to 0\n"],[1,"    "],[0,"3.  Invo"]],"start1":7198,"start2":7198,"length1":16,"length2":20},{"diffs":[[0," method\n"],[1,"    "],[0,"4.  If i"]],"start1":7235,"start2":7235,"length1":16,"length2":20},{"diffs":[[0,"efault)\n"],[1,"    "],[0,"5.  Eith"]],"start1":7369,"start2":7369,"length1":16,"length2":20},{"diffs":[[0,"t again\n"],[1,"    "],[0,"6.  Time"]],"start1":7498,"start2":7498,"length1":16,"length2":20},{"diffs":[[0,"d takes\n"],[1,"    "],[0,"7.  Retu"]],"start1":7560,"start2":7560,"length1":16,"length2":20}]],"length":15530,"saved":false}
{"contributors":[],"silentsave":false,"ts":1367350877359,"patch":[[{"diffs":[[0,"(DAO).\n\n"],[1,"At the end you could decorate your method with annotations/aspects like this:\n\n``` java Example\n@Timeit\n@Retry\n@Cache\npublic void goGetMyData(String someParam, int anotherOne)\n{\n    // do something\n}\n```\n\n"],[0,"<!-- mor"]],"start1":2060,"start2":2060,"length1":16,"length2":221}]],"length":15735,"saved":false}
{"ts":1367350933817,"patch":[[{"diffs":[[0,"etry"],[-1,"\n@Cache"],[1,"(times=3)\n@Cache(timeToLiveInSeconds=3600)"],[0,"\npub"]],"start1":2174,"start2":2174,"length1":15,"length2":50}]],"length":15770,"saved":false}
{"contributors":[],"silentsave":false,"ts":1367364262948,"patch":[[{"diffs":[[0,"ing anno"],[1,"t"],[0,"ations e"]],"start1":3772,"start2":3772,"length1":16,"length2":17},{"diffs":[[0,"alculate"],[1,"s"],[0,"\nhow lon"]],"start1":6744,"start2":6744,"length1":16,"length2":17},{"diffs":[[0," the Ret"],[1,"r"],[0,"y aspect"]],"start1":7409,"start2":7409,"length1":16,"length2":17}]],"length":15773,"saved":false}
